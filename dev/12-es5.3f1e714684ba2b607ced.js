function _classCallCheck(s,a){if(!(s instanceof a))throw new TypeError("Cannot call a class as a function")}function _defineProperties(s,a){for(var n=0;n<a.length;n++){var e=a[n];e.enumerable=e.enumerable||!1,e.configurable=!0,"value"in e&&(e.writable=!0),Object.defineProperty(s,e.key,e)}}function _createClass(s,a,n){return a&&_defineProperties(s.prototype,a),n&&_defineProperties(s,n),s}(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{CO1m:function(s,a,n){"use strict";n.r(a);var e,p=n("ofXK"),l=n("tyNb"),t=n("2FIb"),r=n("19H1"),o=n("lJxs"),c=n("fXoL"),i=n("sjd8"),h=Object(o.a)((function(s){return s.matches})),b=((e=function(){function s(a){_classCallCheck(this,s),this.breakpointObserver=a}return _createClass(s,[{key:"ngOnInit",value:function(){this.xs$=this.breakpointObserver.observe(r.z.xs).pipe(h),this.sm$=this.breakpointObserver.observe(r.z.sm).pipe(h),this.md$=this.breakpointObserver.observe(r.z.md).pipe(h),this.lg$=this.breakpointObserver.observe(r.z.lg).pipe(h),this.xl$=this.breakpointObserver.observe(r.z.xl).pipe(h),this.xs_sm$=this.breakpointObserver.observe([r.z.xs,r.z.sm]).pipe(h)}}]),s}()).\u0275fac=function(s){return new(s||e)(c.Mb(i.a))},e.\u0275cmp=c.Gb({type:e,selectors:[["ng-component"]],decls:18,vars:18,template:function(s,a){1&s&&(c.Tb(0,"pre"),c.Ac(1),c.fc(2,"async"),c.Rb(),c.Tb(3,"pre"),c.Ac(4),c.fc(5,"async"),c.Rb(),c.Tb(6,"pre"),c.Ac(7),c.fc(8,"async"),c.Rb(),c.Tb(9,"pre"),c.Ac(10),c.fc(11,"async"),c.Rb(),c.Tb(12,"pre"),c.Ac(13),c.fc(14,"async"),c.Rb(),c.Tb(15,"pre"),c.Ac(16),c.fc(17,"async"),c.Rb()),2&s&&(c.zb(1),c.Cc("xs: ",c.gc(2,6,a.xs$),""),c.zb(3),c.Cc("sm: ",c.gc(5,8,a.sm$),""),c.zb(3),c.Cc("md: ",c.gc(8,10,a.md$),""),c.zb(3),c.Cc("lg: ",c.gc(11,12,a.lg$),""),c.zb(3),c.Cc("xl: ",c.gc(14,14,a.xl$),""),c.zb(3),c.Cc("xs_sm: ",c.gc(17,16,a.xs_sm$),""))},pipes:[p.b],encapsulation:2}),e);function m(){return{label:"Breakpoints",tabs:{Demo:b,"README.md":{type:"md",content:'<h1 id="breakpoints">Breakpoints</h1>\n<p>VCL Breakpoint queries to be used with <code>@angular/cdk</code>&apos;s BreakpointObserver or <code>window.matchMedia()</code></p>\n<h3 id="usage">Usage</h3>\n<pre class="hljs"><span class="hljs-keyword">import</span> { VCLBreakpoints } <span class="hljs-keyword">from</span> <span class="hljs-string">&apos;@vcl/ng-vcl&apos;</span>;\n<span class="hljs-keyword">import</span> { BreakpointObserver } <span class="hljs-keyword">from</span> <span class="hljs-string">&apos;@angular/cdk/layout&apos;</span>;\n\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> MyComponent <span class="hljs-keyword">implements</span> OnInit {\n  <span class="hljs-keyword">constructor</span>(<span class="hljs-params">\n    <span class="hljs-keyword">private</span> breakpointObserver: BreakpointObserver,\n  </span>) {}\n\n  xs_sm$: Observable&lt;<span class="hljs-built_in">boolean</span>&gt;;\n\n  ngOnInit(): <span class="hljs-built_in">void</span> {\n    <span class="hljs-keyword">this</span>.xs_sm$ = <span class="hljs-keyword">this</span>.breakpointObserver.observe([VCLBreakpoints.xs, VCLBreakpoints.sm]).pipe(\n      map(<span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> state.matches)\n    );\n  }\n}\n</pre>\n'},"demo.component.html":{type:"pre",content:n("RxtE")},"demo.component.ts":{type:"pre",content:n("PfV2")}}}}n.d(a,"demo",(function(){return m})),n.d(a,"BreakpointsDemoModule",(function(){return j}));var k,j=((k=function s(){_classCallCheck(this,s)}).\u0275mod=c.Kb({type:k}),k.\u0275inj=c.Jb({factory:function(s){return new(s||k)},imports:[[p.c,t.b,l.g.forChild([{path:"",component:t.a,data:{demo:m}}])]]}),k)},PfV2:function(s,a){s.exports='<span class="hljs-keyword">import</span> { Component } <span class="hljs-keyword">from</span> <span class="hljs-string">\'@angular/core\'</span>;\n<span class="hljs-keyword">import</span> { BreakpointObserver, BreakpointState } <span class="hljs-keyword">from</span> <span class="hljs-string">\'@angular/cdk/layout\'</span>;\n<span class="hljs-keyword">import</span> { Observable } <span class="hljs-keyword">from</span> <span class="hljs-string">\'rxjs\'</span>;\n<span class="hljs-keyword">import</span> { VCLBreakpoints } <span class="hljs-keyword">from</span> <span class="hljs-string">\'@vcl/ng-vcl\'</span>;\n<span class="hljs-keyword">import</span> { map } <span class="hljs-keyword">from</span> <span class="hljs-string">\'rxjs/operators\'</span>;\n\n<span class="hljs-keyword">const</span> pickMatches = map(<span class="hljs-function">(<span class="hljs-params">state: BreakpointState</span>) =&gt;</span> state.matches);\n\n<span class="hljs-meta">@Component</span>({\n  templateUrl: <span class="hljs-string">\'demo.component.html\'</span>\n})\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> BreakpointsDemoComponent {\n  <span class="hljs-keyword">constructor</span>(<span class="hljs-params">\n    <span class="hljs-keyword">private</span> breakpointObserver: BreakpointObserver,\n  </span>) {}\n\n  xs$: Observable&lt;<span class="hljs-built_in">boolean</span>&gt;;\n  sm$: Observable&lt;<span class="hljs-built_in">boolean</span>&gt;;\n  md$: Observable&lt;<span class="hljs-built_in">boolean</span>&gt;;\n  lg$: Observable&lt;<span class="hljs-built_in">boolean</span>&gt;;\n  xl$: Observable&lt;<span class="hljs-built_in">boolean</span>&gt;;\n  xs_sm$: Observable&lt;<span class="hljs-built_in">boolean</span>&gt;;\n\n  ngOnInit(): <span class="hljs-built_in">void</span> {\n    <span class="hljs-keyword">this</span>.xs$ = <span class="hljs-keyword">this</span>.breakpointObserver.observe(VCLBreakpoints.xs).pipe(pickMatches);\n    <span class="hljs-keyword">this</span>.sm$ = <span class="hljs-keyword">this</span>.breakpointObserver.observe(VCLBreakpoints.sm).pipe(pickMatches);\n    <span class="hljs-keyword">this</span>.md$ = <span class="hljs-keyword">this</span>.breakpointObserver.observe(VCLBreakpoints.md).pipe(pickMatches);\n    <span class="hljs-keyword">this</span>.lg$ = <span class="hljs-keyword">this</span>.breakpointObserver.observe(VCLBreakpoints.lg).pipe(pickMatches);\n    <span class="hljs-keyword">this</span>.xl$ = <span class="hljs-keyword">this</span>.breakpointObserver.observe(VCLBreakpoints.xl).pipe(pickMatches);\n    <span class="hljs-keyword">this</span>.xs_sm$ = <span class="hljs-keyword">this</span>.breakpointObserver.observe([VCLBreakpoints.xs, VCLBreakpoints.sm]).pipe(pickMatches);\n  }\n}\n'},RxtE:function(s,a){s.exports='<span class="hljs-tag">&lt;<span class="hljs-name">pre</span>&gt;</span>xs: {{xs$ | async}}<span class="hljs-tag">&lt;/<span class="hljs-name">pre</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-name">pre</span>&gt;</span>sm: {{sm$ | async}}<span class="hljs-tag">&lt;/<span class="hljs-name">pre</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-name">pre</span>&gt;</span>md: {{md$ | async}}<span class="hljs-tag">&lt;/<span class="hljs-name">pre</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-name">pre</span>&gt;</span>lg: {{lg$ | async}}<span class="hljs-tag">&lt;/<span class="hljs-name">pre</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-name">pre</span>&gt;</span>xl: {{xl$ | async}}<span class="hljs-tag">&lt;/<span class="hljs-name">pre</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-name">pre</span>&gt;</span>xs_sm: {{xs_sm$ | async}}<span class="hljs-tag">&lt;/<span class="hljs-name">pre</span>&gt;</span>\n'}}]);