"use strict";(self.webpackChunkng_vcl=self.webpackChunkng_vcl||[]).push([[242],{8242:function(e,n,s){s.r(n),s.d(n,{BreakpointsDemoModule:function(){return v},demo:function(){return l}});var r=s(16274),t=s(95454),o=s(62518),p=s(36196),i=s(88561),a=s(84271),c=s(15104);const m=(0,i.U)(e=>e.matches);let b=(()=>{class e{constructor(e){this.breakpointObserver=e}ngOnInit(){this.xs$=this.breakpointObserver.observe(p.uCr.xs).pipe(m),this.sm$=this.breakpointObserver.observe(p.uCr.sm).pipe(m),this.md$=this.breakpointObserver.observe(p.uCr.md).pipe(m),this.lg$=this.breakpointObserver.observe(p.uCr.lg).pipe(m),this.xl$=this.breakpointObserver.observe(p.uCr.xl).pipe(m),this.xs_sm$=this.breakpointObserver.observe([p.uCr.xs,p.uCr.sm]).pipe(m)}}return e.\u0275fac=function(n){return new(n||e)(a.Y36(c.Yg))},e.\u0275cmp=a.Xpm({type:e,selectors:[["ng-component"]],decls:18,vars:18,template:function(e,n){1&e&&(a.TgZ(0,"pre"),a._uU(1),a.ALo(2,"async"),a.qZA(),a.TgZ(3,"pre"),a._uU(4),a.ALo(5,"async"),a.qZA(),a.TgZ(6,"pre"),a._uU(7),a.ALo(8,"async"),a.qZA(),a.TgZ(9,"pre"),a._uU(10),a.ALo(11,"async"),a.qZA(),a.TgZ(12,"pre"),a._uU(13),a.ALo(14,"async"),a.qZA(),a.TgZ(15,"pre"),a._uU(16),a.ALo(17,"async"),a.qZA()),2&e&&(a.xp6(1),a.hij("xs: ",a.lcZ(2,6,n.xs$),""),a.xp6(3),a.hij("sm: ",a.lcZ(5,8,n.sm$),""),a.xp6(3),a.hij("md: ",a.lcZ(8,10,n.md$),""),a.xp6(3),a.hij("lg: ",a.lcZ(11,12,n.lg$),""),a.xp6(3),a.hij("xl: ",a.lcZ(14,14,n.xl$),""),a.xp6(3),a.hij("xs_sm: ",a.lcZ(17,16,n.xs_sm$),""))},pipes:[r.Ov],encapsulation:2}),e})();function l(){return{label:"Breakpoints",tabs:{Demo:b,"README.md":{type:"md",content:"# Breakpoints\n\nVCL Breakpoint queries to be used with `@angular/cdk`'s BreakpointObserver or `window.matchMedia()`\n\n### Usage\n\n```ts\nimport { VCLBreakpoints } from '@vcl/ng-vcl';\nimport { BreakpointObserver } from '@angular/cdk/layout';\n\nexport class MyComponent implements OnInit {\n  constructor(\n    private breakpointObserver: BreakpointObserver,\n  ) {}\n\n  xs_sm$: Observable<boolean>;\n\n  ngOnInit(): void {\n    this.xs_sm$ = this.breakpointObserver.observe([VCLBreakpoints.xs, VCLBreakpoints.sm]).pipe(\n      map(state => state.matches)\n    );\n  }\n}\n\n```\n"},"demo.component.html":{type:"html",content:s(39088)},"demo.component.ts":{type:"ts",content:s(11917)}}}}let v=(()=>{class e{}return e.\u0275fac=function(n){return new(n||e)},e.\u0275mod=a.oAB({type:e}),e.\u0275inj=a.cJS({imports:[[r.ez,o.l,t.Bz.forChild([{path:"",component:o.z,data:{demo:l}}])]]}),e})()},39088:function(e,n,s){s.r(n),n.default="<pre>xs: {{xs$ | async}}</pre>\n<pre>sm: {{sm$ | async}}</pre>\n<pre>md: {{md$ | async}}</pre>\n<pre>lg: {{lg$ | async}}</pre>\n<pre>xl: {{xl$ | async}}</pre>\n<pre>xs_sm: {{xs_sm$ | async}}</pre>\n"},11917:function(e,n,s){s.r(n),n.default="import { Component } from '@angular/core';\nimport { BreakpointObserver, BreakpointState } from '@angular/cdk/layout';\nimport { Observable } from 'rxjs';\nimport { VCLBreakpoints } from '@vcl/ng-vcl';\nimport { map } from 'rxjs/operators';\n\nconst pickMatches = map((state: BreakpointState) => state.matches);\n\n@Component({\n  templateUrl: 'demo.component.html'\n})\nexport class BreakpointsDemoComponent {\n  constructor(\n    private breakpointObserver: BreakpointObserver,\n  ) {}\n\n  xs$: Observable<boolean>;\n  sm$: Observable<boolean>;\n  md$: Observable<boolean>;\n  lg$: Observable<boolean>;\n  xl$: Observable<boolean>;\n  xs_sm$: Observable<boolean>;\n\n  ngOnInit(): void {\n    this.xs$ = this.breakpointObserver.observe(VCLBreakpoints.xs).pipe(pickMatches);\n    this.sm$ = this.breakpointObserver.observe(VCLBreakpoints.sm).pipe(pickMatches);\n    this.md$ = this.breakpointObserver.observe(VCLBreakpoints.md).pipe(pickMatches);\n    this.lg$ = this.breakpointObserver.observe(VCLBreakpoints.lg).pipe(pickMatches);\n    this.xl$ = this.breakpointObserver.observe(VCLBreakpoints.xl).pipe(pickMatches);\n    this.xs_sm$ = this.breakpointObserver.observe([VCLBreakpoints.xs, VCLBreakpoints.sm]).pipe(pickMatches);\n  }\n}\n"}}]);