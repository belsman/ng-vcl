(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{CO1m:function(e,n,s){"use strict";s.r(n),s.d(n,"demo",function(){return l}),s.d(n,"BreakpointsDemoModule",function(){return v});var t=s("ofXK"),r=s("tyNb"),o=s("2FIb"),p=s("19H1"),a=s("lJxs"),i=s("fXoL"),b=s("0MNC");const c=Object(a.a)(e=>e.matches);let m=(()=>{class e{constructor(e){this.breakpointObserver=e}ngOnInit(){this.xs$=this.breakpointObserver.observe(p.w.xs).pipe(c),this.sm$=this.breakpointObserver.observe(p.w.sm).pipe(c),this.md$=this.breakpointObserver.observe(p.w.md).pipe(c),this.lg$=this.breakpointObserver.observe(p.w.lg).pipe(c),this.xl$=this.breakpointObserver.observe(p.w.xl).pipe(c),this.xs_sm$=this.breakpointObserver.observe([p.w.xs,p.w.sm]).pipe(c)}}return e.\u0275fac=function(n){return new(n||e)(i.Kb(b.a))},e.\u0275cmp=i.Eb({type:e,selectors:[["ng-component"]],decls:18,vars:18,template:function(e,n){1&e&&(i.Qb(0,"pre"),i.xc(1),i.bc(2,"async"),i.Pb(),i.Qb(3,"pre"),i.xc(4),i.bc(5,"async"),i.Pb(),i.Qb(6,"pre"),i.xc(7),i.bc(8,"async"),i.Pb(),i.Qb(9,"pre"),i.xc(10),i.bc(11,"async"),i.Pb(),i.Qb(12,"pre"),i.xc(13),i.bc(14,"async"),i.Pb(),i.Qb(15,"pre"),i.xc(16),i.bc(17,"async"),i.Pb()),2&e&&(i.zb(1),i.zc("xs: ",i.cc(2,6,n.xs$),""),i.zb(3),i.zc("sm: ",i.cc(5,8,n.sm$),""),i.zb(3),i.zc("md: ",i.cc(8,10,n.md$),""),i.zb(3),i.zc("lg: ",i.cc(11,12,n.lg$),""),i.zb(3),i.zc("xl: ",i.cc(14,14,n.xl$),""),i.zb(3),i.zc("xs_sm: ",i.cc(17,16,n.xs_sm$),""))},pipes:[t.b],encapsulation:2}),e})();function l(){return{label:"Breakpoints",tabs:{Demo:m,"README.md":{type:"md",content:"# Breakpoints\n\nVCL Breakpoint queries to be used with `@angular/cdk`'s BreakpointObserver or `window.matchMedia()`\n\n### Usage\n\n```ts\nimport { VCLBreakpoints } from '@vcl/ng-vcl';\nimport { BreakpointObserver } from '@angular/cdk/layout';\n\nexport class MyComponent implements OnInit {\n  constructor(\n    private breakpointObserver: BreakpointObserver,\n  ) {}\n\n  xs_sm$: Observable<boolean>;\n\n  ngOnInit(): void {\n    this.xs_sm$ = this.breakpointObserver.observe([VCLBreakpoints.xs, VCLBreakpoints.sm]).pipe(\n      map(state => state.matches)\n    );\n  }\n}\n\n```\n"},"demo.component.html":{type:"html",content:s("Exr4")},"demo.component.ts":{type:"ts",content:s("lRQt")}}}}let v=(()=>{class e{}return e.\u0275fac=function(n){return new(n||e)},e.\u0275mod=i.Ib({type:e}),e.\u0275inj=i.Hb({imports:[[t.c,o.b,r.g.forChild([{path:"",component:o.a,data:{demo:l}}])]]}),e})()},Exr4:function(e,n,s){"use strict";s.r(n),n.default="<pre>xs: {{xs$ | async}}</pre>\n<pre>sm: {{sm$ | async}}</pre>\n<pre>md: {{md$ | async}}</pre>\n<pre>lg: {{lg$ | async}}</pre>\n<pre>xl: {{xl$ | async}}</pre>\n<pre>xs_sm: {{xs_sm$ | async}}</pre>\n"},lRQt:function(e,n,s){"use strict";s.r(n),n.default="import { Component } from '@angular/core';\nimport { BreakpointObserver, BreakpointState } from '@angular/cdk/layout';\nimport { Observable } from 'rxjs';\nimport { VCLBreakpoints } from '@vcl/ng-vcl';\nimport { map } from 'rxjs/operators';\n\nconst pickMatches = map((state: BreakpointState) => state.matches);\n\n@Component({\n  templateUrl: 'demo.component.html'\n})\nexport class BreakpointsDemoComponent {\n  constructor(\n    private breakpointObserver: BreakpointObserver,\n  ) {}\n\n  xs$: Observable<boolean>;\n  sm$: Observable<boolean>;\n  md$: Observable<boolean>;\n  lg$: Observable<boolean>;\n  xl$: Observable<boolean>;\n  xs_sm$: Observable<boolean>;\n\n  ngOnInit(): void {\n    this.xs$ = this.breakpointObserver.observe(VCLBreakpoints.xs).pipe(pickMatches);\n    this.sm$ = this.breakpointObserver.observe(VCLBreakpoints.sm).pipe(pickMatches);\n    this.md$ = this.breakpointObserver.observe(VCLBreakpoints.md).pipe(pickMatches);\n    this.lg$ = this.breakpointObserver.observe(VCLBreakpoints.lg).pipe(pickMatches);\n    this.xl$ = this.breakpointObserver.observe(VCLBreakpoints.xl).pipe(pickMatches);\n    this.xs_sm$ = this.breakpointObserver.observe([VCLBreakpoints.xs, VCLBreakpoints.sm]).pipe(pickMatches);\n  }\n}\n"}}]);